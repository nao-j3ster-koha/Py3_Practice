文字列メソッド


1.str.capitalize()      ー＞ 最初の文字を大文字にし、残りを小文字にした文字列のコピーを返す
    ＜使用例＞
    tstStrings = 'hello,python'
    tstStrings.capitalize()
    ー＞（出力結果）
        'Hello,python'

_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/

2.str.casefold()
    文字列の casefold されたコピーを返す
    casefold された文字列は、大文字小文字に関係ないマッチに使える。
    casefold は、小文字化と似ているが、より積極的な内容になる。
    これは「文字列の大文字小文字の区別をすべて取り去る」ことを意図しているため

    ※casefold のアルゴリズムは Unicode Standard のセクション 3.13 に記述されている
    ＜使用例＞
    testStrings ='Hello, Python'
    testStrings.casefold()
    ー＞（出力結果）
        'hello, python'

_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/

3.str.center(width[, fillchar])
    ー＞width の長さをもつ中央寄せされた文字列を返す。
        パディングには fillchar で指定された値 (デフォルトでは ASCII スペース) が使われる
        width が len(s) 以下なら元の文字列が返される。

    ＜使用例＞
    testStrings = 'Hello'
    testStrings.center(10)
    ー＞（出力結果）
        '  Hello   '

     testStrings.center(10,'#')
     ー＞（出力結果）
        '##Hello###'

_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/

4.str.count(sub[, start[, end]])
    ー＞[start, end] の範囲に、部分文字列 sub が重複せず出現する回数を返す
        オプション引数 start および end はスライス表記と同じように解釈される

    ＜使用例＞
    testStrings ='atEBEBFDHatatRHat'
    testStrings.count('at')
    ー＞（出力結果）
        4

    testStrings.count('at',0,12)
    ー＞（出力結果）
        2

_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/

5.str.encode(encoding="utf-8", errors="strict")
    ー＞文字列のエンコードされたバージョンを「バイト列オブジェクト」として返す
        標準のエンコーディングは 'utf-8'
        標準とは異なるエラー処理を行うために errors を与えることができる。
        標準のエラー処理は 'strict' で、エンコードに関するエラーは UnicodeError を送出する。
        他に利用できる値は
            ・'ignore'    無視する
            ・'replace'   置き換える
            ・'xmlcharrefreplace'
            ・'backslashreplace'
            ・関数 codecs.register_error() によって登録された名前
        これについてはセクション 「エラーハンドラ」 を参照する
        利用可能なエンコーディングの一覧は、セクション 「標準エンコーディング」 を参照する

_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/

6.str.endswith(suffix[, start[, end]])
    ⇒文字列が指定された suffix で終わるなら「True」を、そうでなければ「False」を返す。
    suffix は見つけたい複数の接尾語のタプルでも構まわない。
    オプションの start があれば、その位置から判定を始める。

    <使用例>
    *文字列データの中に「EDC」という文字列が含まれているかを確認
    testStrings = 'ajjghahgjhEDC'
    testStrings.endswith('EDC')
    →（実行結果）
    True

    testStrings.endswith('ABC')
    →（実行結果）
    False

    *文字列データの中で、5文字目以降に「EDC」という文字列が含まれているかを確認
    testStrings = 'ajjghahgjhEDC'
    testStrings.endswith('EDC',5)
    →（実行結果）
    True


    *文字列データの中で、5文字目以降、9文字目までに「EDC」という文字列が含まれているかを確認
    testStrings = 'ajjghahgjhEDC'
    testStrings.endswith('EDC',5,10)
    →（実行結果）
    False


    ※文字列データの中で、「EDC」、「gha」の文字列が含まれているかを確認
    testStrings = 'ajjghahgjhEDC'
    testStrings.endswith(('EDC','gha'))
    →(実行結果）
    True

    testStrings.endswith(('EDC','ghh'))     #複数の条件指定の中で異なるものを含む条件に変更
    →(実行結果）
    True                                    # 検索の条件はOR条件

_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/

7.str.expandtabs(tabsize=8)
    →文字列内の全てのタブ文字が 1 つ以上のスペースで置換された、文字列のコピーを返す。
    　スペースの数は現在の桁 (column) 位置と tabsize に依存する
    　タブ位置は tabsize 文字毎に存在する
    　（デフォルト値である 8 の場合、タブ位置は 0, 8, 16 などになる）
    　文字列を展開するため、まず現桁位置がゼロにセットされ、文字列が 1 文字ずつ調べられる。
    　文字がタブ文字 (\t) であれば、現桁位置が次のタブ位置と一致するまで、1 つ以上のスペースが結果の文字列に挿入される。
    　（※タブ文字自体はコピーされない※）
    　文字が改行文字 (\n もしくは \r) の場合、文字がコピーされ、現桁位置は 0 にリセットされる。
    　その他の文字は変更されずにコピーされ、現桁位置は、その文字の表示のされ方 (訳注: 全角、半角など) に関係なく、1 ずつ増加する。

    <使用例>
    '01\t012\t0123\t01234'.expandtabs()     # デフォルトのタブサイズ8
    →（実行結果）
    '01      012     0123    01234'

    '01\t012\t0123\t01234'.expandtabs(4)
    →（実行結果）
    '01  012 0123    01234'

_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/

8.str.find(sub[, start[, end]])
    →文字列のスライス s[start:end] に部分文字列 sub が含まれる場合、その最小のインデックスを返す
    　オプション引数 start および end はスライス表記と同様に解釈される。
    　sub が見つからなかった場合 -1 を返す。

    <使用例>
    testStrings = 'ajjghahgjhEDC'
    testStrings.find('EDC')             # 文字列データ内の「EDC」文字列開始インデックスを確認する
    →(実行結果)
    10

    testStrings.find('EDC',5)             # 文字列データ内の5文字目以降で「EDC」文字列開始インデックスを確認する
    →(実行結果)
    10

    testStrings.find('EDC',5,9)             # 文字列データ内の5文字目～8文字目の間で「EDC」文字列開始インデックスを確認する
    →(実行結果)
    -1

    [注釈]
    ※ find() メソッドは、 sub の位置を知りたいときにのみ使うべき
    ※sub が部分文字列であるかどうかのみを調べるには、 in 演算子を使った方がよい
    　例）
    　'Py' in 'Python'
    　⇒True

_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/

9.str.format(*args, **kwargs)
    →文字列の書式化操作を行う。このメソッドを呼び出す文字列は通常の文字、または、 {} で区切られた置換フィールドを含む。
    　それぞれの置換フィールドは位置引数のインデックスナンバー、または、キーワード引数の名前を含む。
    　返り値は、それぞれの置換フィールドが対応する引数の文字列値で置換された文字列のコピーになる。

    <使用例>
    "The sum of 1 + 2 is {0}".format(1+2)
    →(実行結果）
    'The sum of 1 + 2 is 3'

    ※書式指定のオプションについては、書式指定文字列を規定する 書式指定文字列の文法 を参照
    「書式指定文字列の文法」　https://docs.python.org/ja/3.5/library/string.html#formatstrings

    ※複数の文字列変数を埋め込む場合
    str1 = 'Python'
    str2 = 'Great!!'
    "{0} is {1}".format(str1, str2)
    →(実行結果）
    'Python is Great!!'

_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/
???
10.str.format_map(mapping)
    →

    ＜使用例＞
    >>> class Default(dict):
    ...     def __missing__(self, key):
    ...         return key
    ...
    >>> '{name} was born in {country}'.format_map(Default(name='Guido'))
    'Guido was born in country'

_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/

11.str.index(sub[, start[, end]])
    →find()と同様だが、部分文字列が見つからなかったとき ValueError を送出する。

    ＜使用例＞
    1):正常に検索できる場合
    testStrings = 'ajjghahgjhEDC'
    testStrings.index('EDC')             # 文字列データ内の「EDC」文字列開始インデックスを確認する
    →(実行結果)
    10

    2):検索で見つからない場合
    testStrings = 'ajjghahgjhEDC'
    testStrings.index('EDH')             # 文字列データ内の「EDH」文字列開始インデックスを確認する
    →(実行結果)
    Traceback (most recent call last):
      File "<input>", line 1, in <module>
    ValueError: substring not found

    3):検索範囲の開始位置を指定する場合（正常系）
    testStrings.index('EDC',5)             # 文字列データ内の5文字目以降で「EDC」文字列開始インデックスを確認する
    →(実行結果)
    10

    4):検索範囲の開始位置を指定する場合（異常系）
    testStrings.index('EDH',5)             # 文字列データ内の5文字目以降で「EDH」文字列開始インデックスを確認する
    →(実行結果)
    Traceback (most recent call last):
      File "<input>", line 1, in <module>
    ValueError: substring not found

    5):検索範囲の開始位置と終了位置を指定する場合（正常系）
    testStrings.index('EDC',5,13)             # 文字列データ内の5文字目～13文字目の間で「EDC」文字列開始インデックスを確認する
    →(実行結果)
    10

    6):検索範囲の開始位置と終了位置を指定する場合（異常系）
    testStrings.index('EDC',5,12)             # 文字列データ内の5文字目～12文字目の間で「EDC」文字列開始インデックスを確認する
    →(実行結果)
    Traceback (most recent call last):          # 検索範囲が１２文字目までだと「EDC」ではなく、「ED」のみになるため
      File "<input>", line 1, in <module>
    ValueError: substring not found

_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/

12.str.isalnum()
    →文字列中の「全て」の文字が英数字で、かつ 1 文字以上あるなら真を、そうでなければ偽を返す。

    ＜使用例＞
    1):検索対象に数字が含まれている場合（正常）
    testStrings = '1'
    testStrings.isalnum()
    →（実行結果）
    True

    2):検索対象に英数字以外が含まれている場合（異常）
    testStrings = '1#hjkjha7877'
    testStrings.isalnum()
    →（実行結果）
    False

_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/













